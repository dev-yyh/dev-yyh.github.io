---
title: "점근 표기법 (asymptotic notation) 이해"
permalink: /Algorithm/5
tags:
    - Algorithm
date: "2024-09-08"
thumbnail: "/assets/img/thumbnail/algorithm.webp"
---

# 점근 표기법 (asymptotic notation)
---

`점근적(Asymptotic)`이란 함수의 입력 크기가 무한대로 증가할 때 함수가 특정 값이나 경계에 접근할 때의 동작을 나타냅니다.

`점근 표기법`은 알고리즘의 성능을 복잡한 수식을 간소화하여 표현하는 방법입니다. 실행 시간이 환경에 따라 달라지기 때문에(예: 하드웨어, 운영체제, 언어 등) 정확한 실행 시간을 비교하기보다는, 알고리즘이 수행하는 기본 연산의 횟수를 기준으로 효율성을 측정합니다.

어떤 알고리즘이 수행하는 연산 횟수는 그 입력 크기 n에 따라 함수로 표현됩니다. 예를 들어: 

$$ T(n) = n^2 + 3n + 1 $$

함수가 복잡할수록 어느 알고리즘이 효율적인지 비교하는 것은 어려워지기 때문에 함수를 단순화하기 위해 점근 표기법을 사용하고 이것으로 시간과 공간 복잡도를 표현할 수 있습니다.

## 왜 점근 표기법을 사용하는가?
---

예를 들어 $$ T(n) = n^2+3n+1 $$ 인 시간 복잡도를 $$ n^2 $$ 와 $$3n+1$$로 나누어 그래프로 나타내면 다음과 같습니다.

!["Asymptotic notation)"](/assets/img/posts/Algorithm/5/1.webp "Asymptotic notation"){:class="img-lg"}

$$ n $$에 값이 증가할 수록 $$ 3n+1 $$에 값이 전체 시간 복잡도에 끼치는 영향은 미미하게 됩니다.

즉 $$n$$에 값이 증가할 수록 최고차항 이하의 값들은 함수 증가율에 큰 영향을 끼치지 않습니다.

이렇듯 점근 표기법은 함수의 증가율에 따른 다른 함수와 비교를 하는 것이 목표이기 때문에 최고차항을 제외한 모든 항과 최고차항의 계수는 무시합니다.

두 알고리즘을 생각해봅시다:
- **알고리즘 1**: $$ T(n) = 10000n + 20000 $$
- **알고리즘 2**: $$ T(n) = n^2 + 3n + 1 $$

처음에는 어느 알고리즘이 더 효율적인지 판단하기 어렵지만, 점근 표기법을 사용하여 간소화하면 명확해집니다:

- **알고리즘 1**: $$ T(n) = O(n) $$
- **알고리즘 2**: $$ T(n) = O(n^2) $$

이제 **알고리즘 1**이 더 효율적이라는 것을 쉽게 알 수 있습니다. 왜냐하면 성장 속도가 더 느리기 때문입니다.

## 점근 표기법의 세 가지 주요 유형
---

알고리즘의 시간 복잡도를 표현하기 위해 세 가지 주요 점근 표기법을 사용합니다.

### 1. 빅오 표기법 (Big-O notation)

빅오 표기법은 복잡도의 **상한**을 설명합니다. 즉, **최악의 경우**에 알고리즘이 어떻게 동작하는지를 나타냅니다.

빅오 표기는 다음과 같이 표시합니다.

$$ f(n) = O(g(n)) $$

이때 $$g(n)$$을 함수 $$f(n)$$의 `점근적 상한(asymptotic upper bound)`이라고 합니다.

즉 $$f(n)$$의 복잡도는 최악의 경우라도 $$g(n)$$ 보다 작거나 같다는 의미입니다. ($$f(n) ≤ g(n)$$)

![Big-O graph](/assets/img/posts/Algorithm/5/2.webp "Big-O graph"){:class="img-lg"}

빅오 표기법은 다음과 같이 정의할 수 있습니다:

$$ O(g(n)) = \{ f(n): \exists c, n_0 \text{ such that } 0 \leq f(n) \leq c \cdot g(n) \text{ for all } n \geq n_0 \} $$

### 2. 빅 오메가(Ω) 표기법 (Big-Ω notation)

빅 오메 표기법은 복잡도의 **하한**을 나타냅니다. 즉, **최선의 경우**에 알고리즘이 어느 정도로 빠르게 동작할 수 있는지를 보여줍니다.

빅 오메가 표기는 다음과 같이 표시합니다.

$$ f(n) = \Omega(g(n)) $$

이때 $$g(n)$$을 함수 $$f(n)$$의 `점근적 하한(asymptotic lower bound)`이라고 합니다.

즉 $$f(n)$$의 복잡도는 최선의 경우라도 $$g(n)$$ 보다 크거나 같다는 의미입니다. ($$f(n) ≥ g(n)$$)

![Big Omega graph](/assets/img/posts/Algorithm/5/3.webp "Big Omega graph"){:class="img-lg"}

이를 수식으로 나타내면 다음과 같습니다.

$$ \Omega(g(n)) = \{ f(n): \exists c, n_0 \text{ such that } 0 \leq c \cdot g(n) \leq f(n) \text{ for all } n \geq n_0 \} $$

### 3. 빅 세타(Θ) 표기법 (Big-Θ notation)

빅 세타 표기법은 알고리즘의 성능이 **상한과 하한**에 모두 포함되는 경우를 설명합니다. 즉, 알고리즘의 성능이 상한과 하한 내에서 일정하게 유지된다는 의미입니다.

빅 세타 표기는 다음과 같이 표시합니다.

$$ f(n) = \Theta(g(n)) $$

이때 $$g(n)$$을 함수 $$f(n)$$의 `점근적 상한 및 하한(asymptotic tight bound)`이라고 합니다.

즉 $$f(n)$$의 복잡도가 최선의 경우나 최악의 경우라도 $$g(n)$$ 범위 내에 있다는 의미입니다. (대략 $$f(n) = g(n)$$)

![Big Theta graph](/assets/img/posts/Algorithm/5/4.webp "Big Theta graph"){:class="img-lg"}

이를 수식으로 나타내면 다음과 같습니다.

$$ \Theta(g(n)) = \{ f(n): \exists c_1, c_2, n_0 \text{ such that } 0 \leq c_1 \cdot g(n) \leq f(n) \leq c_2 \cdot g(n) \text{ for all } n \geq n_0 \} $$

## 결론
---

알고리즘 분석에서 **점근 표기법**을 이해하는 것은 대규모 입력에 대해 알고리즘의 효율성을 평가하는 데 매우 중요한 역할을 합니다.
최악의 경우(Big O), 최선의 경우(Big Ω), 그리고 평균적인 성능(Big Θ)을 모두 파악함으로써 알고리즘의 성능을 간소화하고 쉽게 비교할 수 있습니다.

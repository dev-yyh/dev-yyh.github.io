---
title: "큐(Queue) 이해"
permalink: /DataStructure/5
tags:
    - Data Structure
date: "2024-09-02"
thumbnail: "/assets/img/thumbnail/DS.webp"
---

# 큐(Queue) 알아보기
---

## 큐(Queue) 란?
---

큐는 먼저 집어넣은 데이터가 먼저 나오는 `FIFO (First In First Out)` 구조로 저장하는 선형 자료구조입니다.
실제 예로 매표소 대기열에서 먼저 줄을 선 사람이 먼저 나갈 수 있는 상황과 비슷합니다.

나중에 집어넣은 데이터가 먼저 나오는 스택(Stack)과는 반대되는 개념입니다.

## 큐 표현
---

![Queue](/assets/img/posts/DS/5/1.webp "Queue"){:class="img-lg"}

### 핵심 개념: FIFO / LILO

큐는 FIFO / LILO 순서를 따릅니다.
- **FIFO(First In First Out)** : 처음 들어온 값이 처음에 나가는 것
- **LILO(Last In Last Out)** : 마지막에 들어온 값이 마지막에 나가는 것

큐의 모든 작업은 순서대로 처리됩니다.
큐에 `끝(Rear)`에서 요소를 추가하는 작업을 `enqueue`라고 하며 큐에 맨 `앞(Front)`에서 요소를 제거하는 작업을 `dequeue`라고 합니다.

### 큐 상태: 오버플로 및 언더플로

- **오버플로(Overflow)**: 
    - 이미 가득 찬 큐에 요소를 추가하려고 할 때 발생합니다. 이 상태에서는 일부 요소가 제거될 때까지 요소를 추가할 수 없습니다.
- **언더플로우(Underflow)**: 
    - 빈 큐에서 요소를 제거하려고 할 때 발생합니다. 제거할 요소가 없으므로 작업이 실패합니다.

두 경우 모두 프로그램이 충돌하거나 예기치 않게 작동하는 것을 방지하려면 적절한 오류 처리가 중요합니다.

## 큐 기본 동작
---

스택은 아래 연산들로 추상화할 수 있습니다.
- **enqueue(x)**: 큐에 끝(rear)에 `x` 항목을 추가합니다.
- **dequeue()**: 큐에 맨 앞(front)에 항목을 제거합니다.
- **peek()**: 큐에 맨 앞(front)에 있는 항목을 제거하지 않고 반환합니다.
- **isFull()**: 큐가 가득 찼는지 확인합니다.
- **isEmpty()**: 큐가 비어 있는지 확인합니다.

## 큐 시간 복잡도
---

- **Enqueue 작업: `O(1)`**
    - 요소를 큐의 끝(rear)에 추가하기 때문에 상수 시간입니다.
- **Dequeue 작업: `O(1)`**
    - 큐의 맨 앞(front)에 있는 요소를 제거하기 때문에 상수 시간입니다.
- **Access 작업: `O(n)`**
    - 큐의 특정 위치에 액세스하려면 큐의 앞쪽에서 원하는 위치까지 순회해야 합니다.
    - 큐의 끝(rear)이나 앞(front)에 접근한다면 `O(1)`입니다.
- **Search 작업: `O(n)`**
    - 큐의 모든 요소를 ​​순회할 수 있으므로 선형 시간입니다.

## 큐 구현
---

큐를 구현하는 방법에는 두 가지가 있습니다.

### 1. 배열을 사용한 큐 구현
배열은 큐를 구현하는 간단한 방법입니다.

- 장점:
    - **구현 용이성**: 배열은 이해하고 사용하기 쉽습니다.
    - **빠른 접근**: 직접 인덱싱으로 인해 배열의 요소에 액세스하는 속도가 빠릅니다.
- 단점:
    - **고정 크기**: 가장 큰 단점은 큐 생성 시 큐 크기가 고정된다는 것입니다. 더 큰 공간이 필요한 경우 새 큐를 만들고 요소를 복사해야 하는데 이는 비효율적일 수 있습니다.

### 2. 연결 리스트 사용
연결 리스트는 큐의 동적 구현을 ​​제공하여 필요에 따라 큐를 늘리거나 줄일 수 있습니다.

- 장점 : 
    - **동적 크기**: 큐는 필요에 따라 늘리거나 줄일 수 있으므로 배열 기반 큐보다 더 유연합니다.
    - **효율적인 메모리 사용**: 필요할 때만 메모리가 할당됩니다.
- 단점 : 
    - **메모리 오버헤드**: 각 요소에는 포인터를 위한 추가 메모리가 필요하며 이는 많은 양의 데이터를 관리할 때 단점이 될 수 있습니다.

## 큐 종류
---

큐에는 선형과 환형이 있습니다.

### 1. 선형 큐 (Linear Queue)

![Linear Queue](/assets/img/posts/DS/5/1.webp "Linear Queue"){:class="img-lg"}

기본적인 큐의 형태로써 막대 모양으로 된 큐입니다.

배열로 구현 시 크기가 제한되어 있고 빈 공간을 사용하려면 모든 자료를 꺼내거나 자료를 한 칸씩 옮겨야 한다는 단점이 있습니다.
많은 수의 enqueue 및 dequeue 작업이 있는 경우 어느 시점에서 큐가 비어있어도 자료를 삽입하지 못하는 경우가 발생합니다.

### 2. 원형 큐 (Circular Queue)

![Circular Queue](/assets/img/posts/DS/5/2.webp "Circular Queue"){:class="img-lg"}

선형 큐의 문제점을 보완한 것이 환형 큐입니다.
원형 큐는 1차원 배열 형태의 큐를 `원형(Circular)`으로 구성하여 배열의 처음과 끝을 연결하여 만듭니다.
이 설정을 통해 공간을 지속적으로 사용할 수 있으며 데이터 이동의 비효율성을 피할 수 있습니다.

## 큐의 사용 사례
---

1. 어떠한 작업/데이터를 순서대로 실행/사용하기 위해 대기시킬 때 사용합니다.
    - ex) CPU 스케줄링, 디스크 스케줄링
2. 서로 다른 쓰레드 또는 프로세스 사이에서 자료를 주고 받을 때 자료를 일시적으로 저장하는 용도로 많이 사용합니다. (비동기 전송)
    - ex) IO 버퍼, 파이프, 파일 IO 
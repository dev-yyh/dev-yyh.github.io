---
title: "스택(Stack) 이해"
permalink: /DataStructure/4
tags:
    - Data Structure
date: "2024-09-01"
thumbnail: "/assets/img/thumbnail/DS.webp"
---

# 스택(Stack) 알아보기
---

## 스택(Stack) 이란?
---

스택은 한쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조로 되어 있습니다.

식당에 쌓여있는 접시들이 좋은 예입니다. 순서대로 쌓인 접시가 스택 구조와 같습니다.
접시가 필요하면 제일 위에 있는 접시부터 사용하며 가장 아래 있는 접시는 마지막에 사용됩니다.

![Stack](/assets/img/posts/DS/4/1.webp "Stack"){:class="img-md"}

### 핵심 개념: LIFO / FILO

스택은 LIFO / FILO 순서를 따릅니다.
- **LIFO(Last In, First Out)** : 마지막으로 들어온 값이 처음으로 나가는 것
- **FILO(First In, Last Out)** : 처음 들어온 값이 마지막에 나가는 것

스택의 모든 작업은 `Top`이라는 스택의 한쪽 끝에서만 일어납니다.

### 스택 상태: 오버플로 및 언더플로

- **오버플로(Overflow)**: 
    - 이미 가득 찬 스택에 요소를 푸시(추가)하려고 할 때 발생합니다. 이 상태에서는 일부 요소가 제거될 때까지 요소를 추가할 수 없습니다.
- **언더플로우(Underflow)**: 
    - 빈 스택에서 요소를 팝(제거)하려고 할 때 발생합니다. 제거할 요소가 없으므로 작업이 실패합니다.

두 경우 모두 프로그램이 충돌하거나 예기치 않게 작동하는 것을 방지하려면 적절한 오류 처리가 중요합니다.


## 추상 자료형(ADT)
---

스택은 아래 연산들로 추상화할 수 있습니다.
- **push(x)**: `x` 항목을 스택 맨 위에 추가합니다.
- **pop()**: 스택 맨 위에 있는 항목을 제거합니다.
- **peek() 또는 top()**: 스택 맨 위에 있는 항목을 제거하지 않고 반환합니다.
- **isEmpty()**: 스택이 비어 있는지 확인합니다.
- **isFull()**: 스택이 가득 찼는지 확인합니다(고정 크기 스택의 경우).
- **getSize()**: 스택에 있는 현재 요소 수를 반환합니다.

## 스택 기본 동작
---

### Push 작업 

데이터를 스택에 넣는 작업을 `push` 라고 합니다. push는 다음 단계를 거칩니다.

1. 가득찼는지 확인: 
    - 먼저 스택이 가득 찼는지 확인합니다. 가득 찼다면 `오버플로` 오류가 발생합니다.
2. Top 증분: 
    - 스택이 가득 차지 않은 경우 `Top` 인덱스를 증분하여 다음 사용 가능한 위치를 가리킵니다.
3. 데이터 추가: 
    - `Top`이 가리키는 위치에 새 항목을 배치합니다.

![Stack push](/assets/img/posts/DS/4/2.webp "Stack push"){:class="img-lg"}

### Pop 작업

데이터를 스택에 제거하는 작업을 `pop`이라고 합니다. pop은 다음 단계를 거칩니다.

1. 비어 있는지 확인: 
    - 먼저 스택이 비어 있는지 확인합니다. 비어 있다면 `언더플로우` 오류가 발생합니다.
2. 데이터 제거: 
    - 스택이 비어 있지 않으면 Top이 가리키는 항목을 제거합니다.
3. 상단 감소: 
    - `Top` 인덱스를 감소시켜 스택의 새로운 Top을 가리킵니다.

![Stack pop](/assets/img/posts/DS/4/3.webp "Stack pop"){:class="img-lg"}

### Peek 작업

`peek` 작업을 사용하면 항목을 제거하지 않고도 스택 맨 위에 있는 항목을 볼 수 있습니다.
이 작업은 스택의 내용을 변경하지 않고 스택에 추가된 가장 최근 항목을 확인해야 할 때 유용합니다.

### IsEmpty 및 IsFull 작업
1. **isEmpty**: 
    - 스택에 요소가 없으면 true를 반환하고 그렇지 않으면 false를 반환합니다. 이는 pop 작업을 수행하기 전에 확인하는 데 유용합니다.
2. **isFull**: 
    - 스택이 최대 용량에 도달한 경우(고정 크기 스택과 관련) true를 반환하고, 그렇지 않으면 false를 반환합니다. 이는 push 작업 전에 중요합니다.

## 스택 시간 복잡도
---

- **Push 작업: `O(1)`**
    - Top 위에 요소를 추가하기 때문에 상수 시간입니다.
- **Pop 연산: `O(1)`**
    - Top 요소만 제거하기 때문에 상수 시간입니다.
- **Top/Peek 작업: `O(1)`** 
    - 단순히 Top 요소에 액세스하기 때문에 상수 시간입니다.
- **Search 작업: `O(n)`** 
    - 스택의 모든 요소를 ​​순회할 수 있으므로 선형 시간입니다.

### 스택 작업이 효율적인 이유

스택 작업은 Top에 있는 요소를 추가, 제거 또는 액세스하는 작업만 포함하므로 효율적입니다.
전체 스택을 탐색하거나 요소를 이동할 필요가 없으므로 이러한 작업의 시간 복잡성이 일정하게 유지됩니다.

## 스택 구현
---

스택을 구현하는 방법에는 두 가지가 있습니다.

### 1. 배열을 사용한 스택 구현
배열은 스택을 구현하는 간단한 방법입니다.

- 장점:
    - **구현 용이성**: 배열은 이해하고 사용하기 쉽습니다.
    - **빠른 접근**: 직접 인덱싱으로 인해 배열의 요소에 액세스하는 속도가 빠릅니다.
- 단점:
    - **고정 크기**: 가장 큰 단점은 스택 생성 시 스택 크기가 고정된다는 것입니다. 더 큰 스택이 필요한 경우 새 스택을 만들고 요소를 복사해야 하는데 이는 비효율적일 수 있습니다.


### 2. 연결 리스트 사용
연결 리스트는 스택의 동적 구현을 ​​제공하여 필요에 따라 스택을 늘리거나 줄일 수 있습니다.

- 장점 : 
    - **동적 크기**: 스택은 필요에 따라 늘리거나 줄일 수 있으므로 배열 기반 스택보다 더 유연합니다.
    - **효율적인 메모리 사용**: 필요할 때만 메모리가 할당됩니다.
- 단점 : 
    - **메모리 오버헤드**: 각 요소에는 포인터를 위한 추가 메모리가 필요하며 이는 많은 양의 데이터를 관리할 때 단점이 될 수 있습니다.

## 스택(Stack)의 사용 사례
---

1. **재귀 함수 호출**: 
    - 시스템 호출 스택은 활성 함수를 추적합니다. 함수가 호출될 때마다 스택에 푸시되고, 반환되면 팝됩니다.
2. **실행 취소(Undo) 메커니즘**: 
    - 변경할 때마다 스택에 푸시됩니다. 변경 사항을 실행 취소하면 스택에서 마지막 작업이 제거되고 되돌려집니다.
3. **브라우저 기록**: 
    - 웹 브라우저는 스택을 사용하여 방문하는 페이지를 추적합니다. "뒤로"를 클릭하면 현재 페이지가 스택에서 사라지고 이전 페이지가 로드됩니다.
4. **표현식 구문 분석**: 
    - 스택은 표현식을 구문 분석(예: 중위어를 후위 표기법으로 변환)하고, 후위 표현식을 평가하거나, 계산기와 같은 언어의 표현식을 처리하는 데 사용됩니다.
5. **역추적(Backtracking) 문제**:
    - 스택은 역추적 문제를 해결할 때 사용됩니다.
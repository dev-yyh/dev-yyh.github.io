---
title: "연결 리스트(linked list) 이해"
permalink: /DataStructure/3
tags:
    - Data Structure
date: "2024-08-30"
thumbnail: "/assets/img/thumbnail/DS.webp"
---

# 연결 리스트(linked list) 알아보기
---
데이터를 효율적으로 관리하려면 고정 크기의 배열로는 한계가 있습니다.

메모리의 연속된 공간을 필요로 하는 배열과 달리, 연결 리스트는 노드를 포인터로 연결하는 창의적인 데이터 구조입니다. 

연결 리스트는 배열처럼 하나의 메모리 블록에 저장될 필요가 없기 때문에 매우 유연하고 동적입니다.

## 연결 리스트(linked list)란?
---

연결리스트는 데이터와 포인트로 구성된 노드간의 `연결(link)`을 이용해서 리스트를 구현한 자료구조입니다.

연결리스트는 배열의 고정크기의 단점을 보완하기 위해 만들어 졌으며 배열과 달리 연속적인 메모리 공간에 저장되어 있지 않기 때문에 연결이 필요합니다.

연결 리스트는 아래 그림과 같이 포인터를 사용하여 각 노드를 연결합니다.

![Linked list](/assets/img/posts/DS/3/1.webp "Linked list"){:class="img-lg"}

- `Head`: 리스트의 시작 지점입니다.
- `Node`: 각 노드는 데이터를 포함하고 있으며, `Next`라는 포인터가 있어 다음 노드와 연결됩니다.
- `Last Node`: 리스트의 끝을 나타내며, `NULL`을 가리킵니다.


## 연결 리스트 시간 복잡도
---

### Access: `O(n)`
배열과 달리 연결 리스트의 요소에 액세스하려면 원하는 노드에 도달할 때까지 Head에서 목록을 순회해야 합니다.
최악의 경우 전체 목록을 순회해야 하므로 `O(n)`의 시간 복잡도가 발생할 수 있습니다. 여기서 `n`은 목록의 요소 수입니다.

### Search: `O(n)`
요소에 액세스하는 것과 마찬가지로 연결 목록에서 특정 값을 검색하려면 Head에서 값이 포함된 노드까지 순회해야 합니다.
최악의 경우 전체 목록을 순회해야 하므로 `O(n)`의 시간 복잡도가 발생할 수 있습니다.

### Insert:
- **처음에 삽입 `O(1)`**
     - 연결 리스트의 시작 부분에 요소를 삽입하는 것은 간단합니다. 새 노드를 만들고 새 노드가 이전 헤드를 가리키도록 포인터를 조정한 다음 헤드를 이 새 노드로 업데이트하면 됩니다. 이 작업은 일정한 시간 `O(1)`에 수행됩니다.
- **중간에 삽입 `O(n)`**
     - 특정 위치에 요소를 삽입하려면 먼저 목록을 해당 위치로 이동해야 하며(`O(n)`), 포인터를 조정해야 합니다(`O(1)`). 전체 시간복잡도는 `O(n)`으로 유지됩니다.
- **끝에 삽입: 마지막 요소를 알 수 없으면 `O(n)`, 마지막 요소를 알면 `O(1)`**
     - 단일 연결 리스트의 끝에 삽입하려면 마지막 노드를 직접 참조하는 꼬리 포인터가 없는 한 일반적으로 마지막 노드를 찾기 위한 순회가 필요합니다. 꼬리 포인터를 사용하면 작업은 `O(1)`입니다. 그렇지 않으면 필요한 순회로 인해 `O(n)`이 됩니다.

### Delete:
- **처음에 삭제 `O(1)`**
     - 연결 리스트의 시작 부분에 요소를 삭제하는 것은 간단합니다. 목록의 두 번째 노드를 가리키도록 Head를 업데이트하면 효과적으로 첫 번째 노드가 제거됩니다. 이는 일정한 시간 `O(1)`이 소요됩니다.
- **중간에 삭제 `O(n)`**
     - 중간에서 노드를 삭제하려면 노드를 찾아야 하며(`O(n)`), 포인터를 업데이트해야 합니다(`O(1)`). 전체 시간복잡도는 `O(n)`으로 유지됩니다.
- **끝에서 삭제: 마지막 요소를 알 수 없으면 `O(n)`, 마지막 요소를 알면 `O(1)`**
     - 마지막 노드를 삭제하려면 이전 노드에 대한 포인터가 유지되지 않는 한 마지막에서 두 번째 노드로 순회해야 합니다. 마지막에서 두 번째 노드의 포인터를 사용하면 작업은 `O(1)`입니다. 그렇지 않으면 필요한 순회로 인해 `O(n)`이 됩니다.

## 연결 리스트의 장점과 단점
---

### 장점
1. 크기가 가변적임:
    - 배열과 달리, 연결 리스트는 메모리가 허용하는 한 자유롭게 크기를 늘리거나 줄일 수 있습니다.
2. 삽입 삭제가 쉬움
    - 배열처럼 요소를 이동시킬 필요 없이, 포인터 몇 개만 업데이트하면 노드를 삽입하거나 삭제할 수 있습니다.

### 단점
1. 순차 접근만 가능
     - 인덱싱이 없기 때문에 요소에 접근하려면 처음부터 차례로 접근해야 합니다.
2. 추가 메모리 필요
     - 각 노드는 포인터를 저장하기 위해 추가적인 메모리가 필요하므로, 공간이 더 많이 소모될 수 있습니다.

## 연결 리스트의 종류 살펴보기
---

연결 리스트는 연결 방향에 따라 `단일 연결 리스트`, `이중 연결 리스트`, `원형 연결 리스트`가 있습니다.

### 단일 연결 리스트 (Singly Linked Linear List)

가장 단순한 형태로, 노드들이 `단방향`으로 연결된 리스트입니다.

![Singly Linked Linear List](/assets/img/posts/DS/3/2.webp "Singly Linked Linear List"){:class="img-lg"}

> - 단방향 연결이라 노드는 다음 노드만 알고, 이전 노드는 모릅니다.
> - 마지막 노드의 포인터는 `NULL`로 설정됩니다.

### 이중 연결 리스트 (Doubly Linked Linear List)

노드들이 `양방향`으로 연결된 리스트입니다. 각 노드는 다음 노드와 이전 노드로 연결되는 두 개의 포인터를 가집니다.

![Doubly Linked Linear List](/assets/img/posts/DS/3/3.webp "Doubly Linked Linear List"){:class="img-lg"}

> - 양방향 연결이라 노드 앞뒤로 자유롭게 탐색이 가능합니다.
> - 노드 마다 두 개의 포인터를 가지므로 단순 연결 리스트에 비해 추가 메모리가 필요합니다.

### 원형 연결 리스트 (Circularly Linked Linear List)

- 일반적인 연결 리스트에 마지막 노드와 처음 노드를 연결시켜 `원형`으로 만든 구조입니다.

![Circularly Linked Linear List](/assets/img/posts/DS/3/4.webp "Circularly Linked Linear List"){:class="img-lg"}

> - 마지막 노드의 포인터가 첫 번째 노드로 연결되어 `루프`를 형성합니다.
> - 순환 구조에 적합합니다. 예) 라운드 로빈 스케줄링

## 언제 연결 리스트를 사용해야 할까?
---

1. 동적 메모리 할당:
     - 크기가 동적으로 변하는 데이터 구조에 적합합니다.
2. 빈번한 삽입 및 삭제 작업:
     -  삽입, 삭제 작업이 빈번한 경우 적합합니다.
3. 희소 데이터 구조
     - 연결 리스트는 실제 필요한 데이터만 저장하기 때문에 희소 데이터 구조에 적합합니다.